
import pandas as pd
import os
import streamlit as st
import pydeck as pdk
import plotly.express as px
import plotly.graph_objects as go
import glob
import matplotlib.pyplot as plt
import csv
import requests
from bs4 import BeautifulSoup 

st.set_page_config(page_title='Monitoramento de Dengue no Brasil ao Longo do Tempo.',
                page_icon='ü¶ü',
                layout='wide')
st.markdown(f'''<style>.stApp {{background-color: #212325;}}</style>''', unsafe_allow_html=True)


@st.cache_data
def carregar_dataset():
    
    try:
        # Tente ler cada parte do dataset
        df = pd.read_csv(f'data_sus/df_dengue_2023_2024.csv')
    except FileNotFoundError:
        st.error(f"Arquivo n√£o encontrado.")
    return df  # Retorna um DataFrame vazio se o arquivo n√£o for encontrado

# Carregar o dataset
df = carregar_dataset()
    

# Menu de sele√ß√£o de doen√ßas
doenca = "Dengue"
# Abas para o conte√∫do
abas = st.tabs(["An√°lise por Munic√≠pio", "Informa√ß√µes e Sintomas", "Dados Epidemiol√≥gicos"])

# Aba 1: An√°lise por Munic√≠pio
with abas[0]:
    st.title(f"An√°lise da Situa√ß√£o do Munic√≠pio - {doenca}")

    # Converter a coluna 'data_week' para datetime, caso ainda n√£o tenha sido convertida
    df['data_week'] = pd.to_datetime(df['data_week'], errors='coerce')

    # Selecionar munic√≠pio do usu√°rio
    municipio_usuario = st.selectbox("Selecione seu munic√≠pio", sorted(df['municipio'].astype(str).unique()))
    
    # Compara√ß√£o com outros munic√≠pios do estado
    estado_usuario = df[df['municipio'] == municipio_usuario]['estado'].values[0]
    df_estado = df[df['estado'] == estado_usuario]

    # Definir a data m√°xima (convertida corretamente para datetime)
    data_maxima = df_estado['data_week'].max()

    # Bot√µes para escolha do per√≠odo
    filtro_periodo = st.radio("Filtrar por", ('√öltimo M√™s', '√öltimo Ano'))

    if filtro_periodo == '√öltimo M√™s':
        data_inicial = data_maxima - pd.DateOffset(months=1)
    elif filtro_periodo == '√öltimo Ano':
        data_inicial = data_maxima - pd.DateOffset(years=1)

    # Filtro baseado no per√≠odo selecionado
    df_filtrado = df_estado[(df_estado['data_week'] >= data_inicial) & (df_estado['data_week'] <= data_maxima)]

    # Calcular o √≠ndice de risco
    df_filtrado['risco_dengue'] = (
        df_filtrado['casos_est'] * 0.1 + 
        df_filtrado['casos'] * 0.3 + 
        df_filtrado['incid√™ncia_100khab'] * 0.1 + 
        df_filtrado['dissemina√ß√£o'] * 5
    )

    # Determinar a cor com base no risco (vermelho, amarelo, verde)
    def definir_cor(risco):
        if risco > 7:
            return [255, 0, 0, 160]  # Vermelho (risco alto)
        elif 1 < risco <= 6.99:
            return [255, 255, 0, 160]  # Amarelo (risco moderado)
        else:
            return [0, 255, 0, 160]  # Verde (risco baixo)
    
    df_filtrado['cor'] = df_filtrado['risco_dengue'].apply(definir_cor)
    st.write('''O mapa corresponde a op√ß√£o de um m√™s                            
             Vermelho (risco alto)
             Amarelo (risco moderado)
             Verde (risco baixo)''')

    # Mapa interativo com Pydeck
    layer = pdk.Layer(
        'ScatterplotLayer',
        data=df_filtrado,
        get_position='[longitude, latitude]',
        get_radius='5000',  # Ajuste para evitar sobreposi√ß√£o
        get_fill_color='cor',
        pickable=True,
        auto_highlight=True,
        tooltip=True
    )

    view_state = pdk.ViewState(
        latitude=df_filtrado['latitude'].mean(),
        longitude=df_filtrado['longitude'].mean(),
        zoom=6
    )

    # Exibi√ß√£o do mapa
    r = pdk.Deck(
        layers=[layer], 
        initial_view_state=view_state,
        
        tooltip={
            'html': '<b>Munic√≠pio:</b> {municipio}<br><b>Casos:</b> {casos}<br><b>Est. Casos:</b> {casos_est}<br><b>Dissemina√ß√£o:</b> {dissemina√ß√£o}<br><b>Temperatura:</b> {tempmed}¬∞C<br><b>Umidade:</b> {umidmed}%',
            'style': {'color': 'white'}
        }
    )
    st.pydeck_chart(r)

    # Criar um dataframe separado para destacar o munic√≠pio selecionado e os extremos (m√≠nimo e m√°ximo) do estado
    df_min_max = df_filtrado.groupby('data_week').agg({
        'casos': ['min', 'max'],
        'incid√™ncia_100khab': ['min', 'max'],
        'dissemina√ß√£o': ['min', 'max'],
        'umidmed': ['min', 'max'],
        'umidmin': ['min', 'max'],
        'umidmax': ['min', 'max'],
        'tempmed': ['min', 'max'],
        'tempmin': ['min', 'max'],
        'tempmax': ['min', 'max']
    }).reset_index()

    # Adicionar os dados do munic√≠pio escolhido
    df_municipio_selecionado = df_filtrado[df_filtrado['municipio'] == municipio_usuario]

    # Gr√°fico de linha com destaque no munic√≠pio selecionado
    fig = go.Figure()

    # Adicionar a linha do munic√≠pio selecionado
    fig.add_trace(go.Scatter(x=df_municipio_selecionado['data_week'], y=df_municipio_selecionado['casos'],
                             mode='lines+markers', name=f'{municipio_usuario} - Casos', line=dict(color='red', width=4)))

    # Adicionar a linha dos casos m√≠nimos do estado
    fig.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('casos', 'min')],
                             mode='lines', name='Casos M√≠nimos (Estado)', line=dict(color='green', dash='dash')))

    # Adicionar a linha dos casos m√°ximos do estado
    fig.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('casos', 'max')],
                             mode='lines', name='Casos M√°ximos (Estado)', line=dict(color='blue', dash='dash')))

    # Adicionar t√≠tulo e r√≥tulos
    fig.update_layout(title=f'Compara√ß√£o de Incid√™ncia de Casos {estado_usuario}',
                      xaxis_title='Semana',
                      yaxis_title='N√∫mero de Casos',
                      legend_title='Munic√≠pios')

    st.plotly_chart(fig)


    # Gr√°fico de linha para Casos Estimados (casos_est)
    fig_casos_est = go.Figure()

    # Adicionar a linha do munic√≠pio selecionado
    fig_casos_est.add_trace(go.Scatter(x=df_municipio_selecionado['incid√™ncia_100khab'], y=df_municipio_selecionado['incid√™ncia_100khab'],
                                    mode='lines+markers', name=f'{municipio_usuario} - Incid√™ncia de casos a cada 100k de habitantes', line=dict(color='red', width=4)))

    # Adicionar a linha dos casos estimados m√≠nimos do estado
    fig_casos_est.add_trace(go.Scatter(x=df_min_max['incid√™ncia_100khab'], y=df_min_max[('incid√™ncia_100khab', 'min')],
                                    mode='lines', name='Incid√™ncia M√≠nima (Estado)', line=dict(color='green', dash='dash')))

    # Adicionar a linha dos casos estimados m√°ximos do estado
    fig_casos_est.add_trace(go.Scatter(x=df_min_max['incid√™ncia_100khab'], y=df_min_max[('incid√™ncia_100khab', 'max')],
                                    mode='lines', name='Casos Incid√™ncia M√°xima (Estado)', line=dict(color='blue', dash='dash')))

    # Adicionar t√≠tulo e r√≥tulos
    fig_casos_est.update_layout(title=f'Compara√ß√£o de Casos Estimados no Estado {estado_usuario}',
                                xaxis_title='Semana',
                                yaxis_title='Casos Estimados',
                                legend_title='Munic√≠pios')

    st.plotly_chart(fig_casos_est)


    # Gr√°fico de linha para Temperatura M√©dia (tempmed)
    fig_tempmed = go.Figure()

    # Adicionar a linha do munic√≠pio selecionado
    fig_tempmed.add_trace(go.Scatter(x=df_municipio_selecionado['data_week'], y=df_municipio_selecionado['tempmed'],
                                    mode='lines+markers', name=f'{municipio_usuario} - Temperatura M√©dia', line=dict(color='red', width=4)))

    # Adicionar a linha da temperatura m√≠nima do estado
    fig_tempmed.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('tempmin', 'min')],
                                    mode='lines', name='Temperatura M√≠nima (Estado)', line=dict(color='green', dash='dash')))

    # Adicionar a linha da temperatura m√°xima do estado
    fig_tempmed.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('tempmax', 'max')],
                                    mode='lines', name='Temperatura M√°xima (Estado)', line=dict(color='blue', dash='dash')))

    # Adicionar t√≠tulo e r√≥tulos
    fig_tempmed.update_layout(title=f'Compara√ß√£o de Temperatura M√©dia no Estado {estado_usuario}',
                            xaxis_title='Semana',
                            yaxis_title='Temperatura M√©dia (¬∞C)',
                            legend_title='Munic√≠pios')

    st.plotly_chart(fig_tempmed)


    # Gr√°fico de linha para Umidade M√©dia (umidmed)
    fig_umidmed = go.Figure()

    # Adicionar a linha do munic√≠pio selecionado
    fig_umidmed.add_trace(go.Scatter(x=df_municipio_selecionado['data_week'], y=df_municipio_selecionado['umidmed'],
                                    mode='lines+markers', name=f'{municipio_usuario} - Umidade M√©dia', line=dict(color='red', width=4)))

    # Adicionar a linha da umidade m√≠nima do estado
    fig_umidmed.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('umidmin', 'min')],
                                    mode='lines', name='Umidade M√≠nima (Estado)', line=dict(color='green', dash='dash')))

    # Adicionar a linha da umidade m√°xima do estado
    fig_umidmed.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('umidmax', 'max')],
                                    mode='lines', name='Umidade M√°xima (Estado)', line=dict(color='blue', dash='dash')))

    # Adicionar t√≠tulo e r√≥tulos
    fig_umidmed.update_layout(title=f'Compara√ß√£o de Umidade M√©dia no Estado {estado_usuario}',
                            xaxis_title='Semana',
                            yaxis_title='Umidade M√©dia (%)',
                            legend_title='Munic√≠pios')

    st.plotly_chart(fig_umidmed)


    # Gr√°fico de linha para Dissemina√ß√£o (dissemina√ß√£o)
    fig_disseminacao = go.Figure()

    # Adicionar a linha do munic√≠pio selecionado
    fig_disseminacao.add_trace(go.Scatter(x=df_municipio_selecionado['data_week'], y=df_municipio_selecionado['dissemina√ß√£o'],
                                        mode='lines+markers', name=f'{municipio_usuario} - Dissemina√ß√£o', line=dict(color='red', width=4)))

    # Adicionar a linha da dissemina√ß√£o m√≠nima do estado
    fig_disseminacao.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('dissemina√ß√£o', 'min')],
                                        mode='lines', name='Dissemina√ß√£o M√≠nima (Estado)', line=dict(color='green', dash='dash')))

    # Adicionar a linha da dissemina√ß√£o m√°xima do estado
    fig_disseminacao.add_trace(go.Scatter(x=df_min_max['data_week'], y=df_min_max[('dissemina√ß√£o', 'max')],
                                        mode='lines', name='Dissemina√ß√£o M√°xima (Estado)', line=dict(color='blue', dash='dash')))

    # Adicionar t√≠tulo e r√≥tulos
    fig_disseminacao.update_layout(title=f'Compara√ß√£o de Dissemina√ß√£o no Estado {estado_usuario}',
                                xaxis_title='Semana',
                                yaxis_title='Dissemina√ß√£o',
                                legend_title='Munic√≠pios')

    st.plotly_chart(fig_disseminacao)

    

    # Mostrar o ranking dos munic√≠pios mais afetados (usando a combina√ß√£o munic√≠pio-estado)
    df_filtrado['municipio_estado'] = df_filtrado['municipio'] + ' - ' + df_filtrado['estado']
    df_rank = df_filtrado[['municipio_estado', 'risco_dengue']].sort_values(by='risco_dengue', ascending=False)
    st.write("Ranking dos munic√≠pios mais afetados:", df_rank)    



# Aba 2: Informa√ß√µes e Sintomas
with abas[1]:
    st.title(f"Informa√ß√µes e Sintomas - {doenca}")

    # Fazer scraping da p√°gina de dengue, por exemplo
    if doenca == "Dengue":
        HEADER = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:129.0) Gecko/20100101 Firefox/129.0'}
        url = 'https://www.gov.br/saude/pt-br/assuntos/saude-de-a-a-z/d/dengue'
        response = requests.get(url, headers=HEADER, timeout=30)
        soup = BeautifulSoup(response.text, 'html.parser')

        # Extrair informa√ß√µes sobre sintomas
        informacoes = soup.find_all('p')
        for info in informacoes:
            st.write(info.get_text())


# Dados epidemiologicos
with abas[2]:
    st.title(f"ü¶üMonitoramento de Dengue no Brasil ao Longo do Tempo.ü¶ü")

    # Incorporar o Power BI no Streamlit
    st.components.v1.iframe("https://app.powerbi.com/view?r=eyJrIjoiYzQyOTI4M2ItZTQwMC00ODg4LWJiNTQtODc5MzljNWIzYzg3IiwidCI6IjlhNTU0YWQzLWI1MmItNDg2Mi1hMzZmLTg0ZDg5MWU1YzcwNSJ9&pageName=ReportSectionbd7616200acb303571fc", height=600)


    st.write('Here you need uplooad the csv with data from 2010 to 2024. \nHas customizable graphics and an interactive map. \n Google Drive Data link: https://drive.google.com/drive/folders/19OGg_d3S9L6wc99I3FZxc5Mn9Ba-jXos?usp=drive_link \n DropBox Data Link: https://www.dropbox.com/scl/fo/wuwb1zpcxuvvlnyfrkcpf/AIBXL31_YW6QpjbWKyG-v2s?rlkey=8vzsj4lddvx5sh61ce8hl2df1&st=zvb71bzb&dl=0')

    uploaded_file = st.file_uploader('Fa√ßa o upload do arquivo da regi√£o desejada.')
    if uploaded_file:
        @st.cache_data
        def load_data(uploaded_file):
            df = pd.read_csv(uploaded_file)
            return df
        
        df = load_data(uploaded_file)       
        st.write('Dados carregados com sucesso!')

        # Certifique-se de que a coluna 'estado' seja do tipo string e remova valores nulos
        df['estado'] = df['estado'].astype(str)
        df = df[df['estado'].notna()]

    else:
        st.write('Nenhum arquivo foi carregado.')

    
    # Multiselect para selecionar as colunas desajas
    selected_columns = st.multiselect("Selecione as colunas. :)", df.columns.tolist(), default=df.columns.tolist())

    # Multiselect para selecionar os estados, ordenados alfabeticamente
    selected_estado = st.multiselect(" Selecione os estados.", sorted(df['estado'].astype(str).unique()))
    df_filtrado = df[(df['estado'].isin(selected_estado))]

    # Multiselect para selecionar os munic√≠pios, ordenados alfabeticamente
    selected_municipio = st.multiselect("Selecione os munic√≠pios.", sorted(df_filtrado['municipio'].astype(str).unique()), default=sorted(df_filtrado['municipio'].astype(str).unique()))
    df_filtrado = df_filtrado[(df_filtrado['municipio'].isin(selected_municipio))]
    st.write('Dados filtrados:/n')
    st.write(len(df_filtrado), ' Registros')
    st.dataframe(df_filtrado[selected_columns])


    def convert_df(df):
        return df.to_csv().encode('utf-8')

    csv = convert_df(df_filtrado)
    # Baixar csv
    st.download_button(
        label='Baixar dados filtrados',
        data=csv,
        file_name='dados_filtrados.csv',
        mime='text/csv',
    )

    if selected_municipio:
        # Converter a coluna para o tipo datetime
        df_filtrado['data_week'] = pd.to_datetime(df_filtrado['data_week'])

        # Selecionar o intervalo de datas para visualiza√ß√£o
        data_inicial = st.date_input('Data inicial', value=df_filtrado['data_week'].min(), min_value=df_filtrado['data_week'].min(), max_value=df_filtrado['data_week'].max())
        data_final = st.date_input('Data final', value=df_filtrado['data_week'].max(), min_value=df_filtrado['data_week'].min(), max_value=df_filtrado['data_week'].max())

        # Filtrar os dados para o intervalo de datas selecionado
        dados_filtrados = df_filtrado[(df_filtrado['data_week'] >= pd.to_datetime(data_inicial)) & (df_filtrado['data_week'] <= pd.to_datetime(data_final))]

        # Agrupar os dados por munic√≠pio e somar os casos e a estimativa de casos
        dados_agrupados = dados_filtrados.groupby(['municipio', 'latitude', 'longitude']).agg(
            casos=('casos', 'sum'),
            casos_est=('casos_est', 'sum'),
            tempmed=('tempmed', 'mean'),  # Somar as temperaturas m√©dias
            umidmed=('umidmed', 'mean')   # Somar as umidades m√©dias
        ).reset_index()

        # Limitar o n√∫mero de casas decimais de tempmed e umidmed
        dados_agrupados['tempmed'] = dados_agrupados['tempmed'].round(2)
        dados_agrupados['umidmed'] = dados_agrupados['umidmed'].round(2)

    # Verificar se h√° dados ap√≥s a filtragem
    if selected_municipio:

        # Criar o mapa interativo
        layer = pdk.Layer(
            'ScatterplotLayer',
            data=dados_agrupados,
            get_position='[longitude, latitude]',  # Coordenadas corretas
            get_radius=9000,  # Ajustar o tamanho dos pontos
            get_fill_color='[255, 0, 0, 160]',  # Vermelho transl√∫cido
            pickable=True
        )

        view_state = pdk.ViewState(
            latitude=-15.7801,  # Posi√ß√£o central do Brasil
            longitude=-47.9292,
            zoom=4,
            pitch=50
        )

        r = pdk.Deck(
            layers=[layer],
            initial_view_state=view_state,
            tooltip={"text": "{municipio} Casos: {casos} Estimativa: {casos_est} Temp: {tempmed} nUmidade: {umidmed} %"}
        )

        st.pydeck_chart(r)


        # Evolu√ß√£o dos casos ao longo do tempo
        fig = px.line(dados_filtrados, x='data_week', y='casos', color='municipio', title='Evolu√ß√£o dos casos ao longo do tempo')
        st.plotly_chart(fig)

        # Temperatura ao longo do tempo
        fig = px.line(dados_filtrados, x='data_week', y='tempmed', color='municipio', title='Temperatura ao longo do tempo')
        st.plotly_chart(fig)
        
        # √ömidade ao longo do tempo
        fig = px.line(dados_filtrados, x='data_week', y='umidmed', color='municipio', title='√ömidade ao longo do tempo')
        st.plotly_chart(fig)
    
    
    if selected_municipio:   
        # Seletor de colunas
        colunas = dados_filtrados.columns.tolist()

        # Gr√°fico de barras
        st.subheader('Gr√°fico de Barras')
        x_col_barra = st.selectbox('Para o eixo X indico selecionar data, municipios ou estados', colunas, key='x_barra')
        y_col_barra = st.selectbox('Para o eixo Y indico selecionar uma coluna num√©rica ', colunas, key='y_barra')

        if x_col_barra and y_col_barra:
            grafico_barra = px.bar(dados_filtrados, x=x_col_barra, y=y_col_barra, title=f'Gr√°fico de Barras: {x_col_barra} vs {y_col_barra}')
            st.plotly_chart(grafico_barra)


        # Gr√°fico de pizza 
        st.subheader('Gr√°fico de Pizza')
        pie_col = st.selectbox('Selecione a coluna para os valores, indico selecionar uma coluna num√©rica', colunas, key='pie')
        pie_col_names = st.selectbox('Selecione a coluna para os nomes como data, municipios ou estados', colunas, key='pie_names')

        if pie_col and pie_col_names:
            grafico_pizza = px.pie(dados_filtrados, values=pie_col, names=pie_col_names, title=f'Gr√°fico de Pizza: {pie_col_names} - {pie_col}')
            st.plotly_chart(grafico_pizza)
            

        # Histograma
        st.subheader('Histograma')
        x_col_histo = st.selectbox('Selecione o eixo x, indico selecionar uma coluna categ√≥rica', colunas, key='x_histo')
        y_col_histo = st.selectbox('Selecione o eixo Y, indico selecionar uma coluna num√©rica', colunas, key='y_histo')
        grafico_histograma = px.histogram(dados_filtrados, x=x_col_histo, y=y_col_histo, nbins=200, )
        st.plotly_chart(grafico_histograma)


